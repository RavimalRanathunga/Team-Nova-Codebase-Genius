"""
Code Analyzer: The Deep-Dive Specialist
JAC Implementation for Codebase Documentation Agent
"""

import:py from tree_sitter, tree_sitter_python;
import:py from pathlib, Path;
import:py from typing, Dict, List, Any, Optional;
import:py import json;
import:py import re;

# Data structures for code analysis
obj CodeElement {
    has name: str;
    has element_type: str;  # 'class', 'function', 'variable', 'import'
    has file_path: str;
    has line_start: int;
    has line_end: int;
    has docstring: Optional[str];
    has parameters: List[str];
    has return_type: Optional[str];
    has dependencies: List[str];
    has complexity_score: int;
}

obj CodeRelationship {
    has source: str;
    has target: str;
    has relationship_type: str;  # 'calls', 'inherits', 'imports', 'uses'
    has file_path: str;
    has line_number: int;
}

obj ParsedFile {
    has file_path: str;
    has elements: List[CodeElement];
    has relationships: List[CodeRelationship];
    has ast_tree: Any;
    has line_count: int;
    has language: str;
}

# Code Analyzer Agent
node CodeAnalyzer {
    has parser: Any;
    has supported_languages: Dict[str, str];
    has analysis_results: Dict[str, ParsedFile];
    has relationship_graph: List[CodeRelationship];
    
    can init {
        # Initialize Tree-sitter parser
        self.parser = tree_sitter.Parser();
        self.supported_languages = {
            "python": "py",
            "javascript": "js",
            "typescript": "ts",
            "java": "java",
            "cpp": "cpp",
            "c": "c"
        };
        self.analysis_results = {};
        self.relationship_graph = [];
        
        # Set up Python parser (can be extended for other languages)
        python_language = tree_sitter_python.language();
        self.parser.set_language(python_language);
    }
    
    # Main analysis entry point
    can analyze_files(file_paths: List[str]) -> Dict[str, Any] {
        """Analyze multiple files and extract code elements and relationships"""
        print("ðŸ” Starting deep code analysis...");
        
        for file_path in file_paths {
            if self.is_supported_file(file_path) {
                print(f"ðŸ“„ Analyzing: {file_path}");
                parsed_file = self.parse_file(file_path);
                if parsed_file {
                    self.analysis_results[file_path] = parsed_file;
                    self.extract_relationships(parsed_file);
                }
            }
        }
        
        # Generate comprehensive analysis report
        analysis_report = self.generate_analysis_report();
        print(f"âœ… Analysis complete! Processed {len(self.analysis_results)} files");
        
        return analysis_report;
    }
    
    # File parsing with Tree-sitter
    can parse_file(file_path: str) -> Optional[ParsedFile] {
        """Parse a single file using Tree-sitter"""
        try {
            file_content = Path(file_path).read_text(encoding='utf-8');
            
            # Parse with Tree-sitter
            tree = self.parser.parse(bytes(file_content, 'utf8'));
            root_node = tree.root_node;
            
            # Extract code elements
            elements = self.extract_code_elements(root_node, file_content, file_path);
            
            # Create parsed file object
            parsed_file = ParsedFile(
                file_path=file_path,
                elements=elements,
                relationships=[],
                ast_tree=tree,
                line_count=len(file_content.split('\n')),
                language=self.detect_language(file_path)
            );
            
            return parsed_file;
        } except Exception as e {
            print(f"âŒ Error parsing {file_path}: {str(e)}");
            return None;
        }
    }
    
    # Extract code elements from AST
    can extract_code_elements(root_node: Any, source_code: str, file_path: str) -> List[CodeElement] {
        """Extract classes, functions, and other code elements from AST"""
        elements = [];
        source_lines = source_code.split('\n');
        
        def traverse_node(node: Any) -> None {
            if node.type == 'class_definition' {
                class_element = self.extract_class_info(node, source_lines, file_path);
                elements.append(class_element);
            }
            elif node.type == 'function_definition' {
                func_element = self.extract_function_info(node, source_lines, file_path);
                elements.append(func_element);
            }
            elif node.type == 'import_statement' or node.type == 'import_from_statement' {
                import_element = self.extract_import_info(node, source_lines, file_path);
                elements.append(import_element);
            }
            
            # Recursively traverse child nodes
            for child in node.children {
                traverse_node(child);
            }
        }
        
        traverse_node(root_node);
        return elements;
    }
    
    # Extract class information
    can extract_class_info(node: Any, source_lines: List[str], file_path: str) -> CodeElement {
        """Extract detailed class information"""
        class_name = self.get_node_text(node.child_by_field_name('name'), source_lines);
        docstring = self.extract_docstring(node, source_lines);
        
        # Find class methods and attributes
        dependencies = [];
        methods = [];
        
        for child in node.children {
            if child.type == 'function_definition' {
                method_name = self.get_node_text(child.child_by_field_name('name'), source_lines);
                methods.append(method_name);
            }
        }
        
        return CodeElement(
            name=class_name,
            element_type='class',
            file_path=file_path,
            line_start=node.start_point[0] + 1,
            line_end=node.end_point[0] + 1,
            docstring=docstring,
            parameters=methods,  # Store methods in parameters field
            return_type=None,
            dependencies=dependencies,
            complexity_score=self.calculate_complexity_score(node)
        );
    }
    
    # Extract function information
    can extract_function_info(node: Any, source_lines: List[str], file_path: str) -> CodeElement {
        """Extract detailed function information"""
        func_name = self.get_node_text(node.child_by_field_name('name'), source_lines);
        docstring = self.extract_docstring(node, source_lines);
        
        # Extract parameters
        parameters = [];
        params_node = node.child_by_field_name('parameters');
        if params_node {
            for param in params_node.children {
                if param.type == 'identifier' {
                    param_name = self.get_node_text(param, source_lines);
                    parameters.append(param_name);
                }
            }
        }
        
        # Extract return type (if available)
        return_type = None;
        type_node = node.child_by_field_name('return_type');
        if type_node {
            return_type = self.get_node_text(type_node, source_lines);
        }
        
        return CodeElement(
            name=func_name,
            element_type='function',
            file_path=file_path,
            line_start=node.start_point[0] + 1,
            line_end=node.end_point[0] + 1,
            docstring=docstring,
            parameters=parameters,
            return_type=return_type,
            dependencies=[],
            complexity_score=self.calculate_complexity_score(node)
        );
    }
    
    # Extract import information
    can extract_import_info(node: Any, source_lines: List[str], file_path: str) -> CodeElement {
        """Extract import statements"""
        import_text = self.get_node_text(node, source_lines);
        
        return CodeElement(
            name=import_text,
            element_type='import',
            file_path=file_path,
            line_start=node.start_point[0] + 1,
            line_end=node.end_point[0] + 1,
            docstring=None,
            parameters=[],
            return_type=None,
            dependencies=[],
            complexity_score=1
        );
    }
    
    # Extract relationships between code elements
    can extract_relationships(parsed_file: ParsedFile) -> None {
        """Analyze relationships between code elements"""
        file_path = parsed_file.file_path;
        
        for element in parsed_file.elements {
            if element.element_type == 'function' or element.element_type == 'class' {
                # Find function calls and dependencies
                relationships = self.find_element_relationships(element, parsed_file);
                self.relationship_graph.extend(relationships);
            }
        }
    }
    
    # Find relationships for a specific element
    can find_element_relationships(element: CodeElement, parsed_file: ParsedFile) -> List[CodeRelationship] {
        """Find relationships for a specific code element"""
        relationships = [];
        
        # Simple pattern matching for function calls (can be enhanced with AST analysis)
        try {
            file_content = Path(element.file_path).read_text(encoding='utf-8');
            lines = file_content.split('\n');
            
            # Look for function calls in the element's code block
            for line_num in range(element.line_start - 1, element.line_end) {
                if line_num < len(lines) {
                    line = lines[line_num];
                    
                    # Find function calls (basic pattern matching)
                    func_calls = re.findall(r'(\w+)\s*\(', line);
                    for func_call in func_calls {
                        if func_call != element.name {  # Don't include self-references
                            relationship = CodeRelationship(
                                source=element.name,
                                target=func_call,
                                relationship_type='calls',
                                file_path=element.file_path,
                                line_number=line_num + 1
                            );
                            relationships.append(relationship);
                        }
                    }
                }
            }
        } except Exception as e {
            print(f"Warning: Could not analyze relationships for {element.name}: {str(e)}");
        }
        
        return relationships;
    }
    
    # Generate comprehensive analysis report
    can generate_analysis_report() -> Dict[str, Any] {
        """Generate a comprehensive analysis report"""
        total_elements = 0;
        element_types = {"class": 0, "function": 0, "import": 0};
        complexity_stats = {"total": 0, "average": 0, "max": 0};
        
        # Calculate statistics
        for file_path, parsed_file in self.analysis_results.items() {
            total_elements += len(parsed_file.elements);
            
            for element in parsed_file.elements {
                if element.element_type in element_types {
                    element_types[element.element_type] += 1;
                }
                complexity_stats["total"] += element.complexity_score;
                complexity_stats["max"] = max(complexity_stats["max"], element.complexity_score);
            }
        }
        
        if total_elements > 0 {
            complexity_stats["average"] = complexity_stats["total"] / total_elements;
        }
        
        # Create detailed report
        report = {
            "summary": {
                "total_files": len(self.analysis_results),
                "total_elements": total_elements,
                "element_breakdown": element_types,
                "complexity_stats": complexity_stats,
                "total_relationships": len(self.relationship_graph)
            },
            "files": {},
            "relationships": [
                {
                    "source": rel.source,
                    "target": rel.target,
                    "type": rel.relationship_type,
                    "file": rel.file_path,
                    "line": rel.line_number
                }
                for rel in self.relationship_graph
            ]
        };
        
        # Add detailed file information
        for file_path, parsed_file in self.analysis_results.items() {
            report["files"][file_path] = {
                "line_count": parsed_file.line_count,
                "language": parsed_file.language,
                "elements": [
                    {
                        "name": elem.name,
                        "type": elem.element_type,
                        "line_start": elem.line_start,
                        "line_end": elem.line_end,
                        "docstring": elem.docstring,
                        "parameters": elem.parameters,
                        "return_type": elem.return_type,
                        "complexity": elem.complexity_score
                    }
                    for elem in parsed_file.elements
                ]
            };
        }
        
        return report;
    }
    
    # Helper methods
    can get_node_text(node: Any, source_lines: List[str]) -> str {
        """Extract text content from AST node"""
        if not node {
            return "";
        }
        
        start_row, start_col = node.start_point;
        end_row, end_col = node.end_point;
        
        if start_row == end_row {
            return source_lines[start_row][start_col:end_col];
        } else {
            result = source_lines[start_row][start_col:];
            for row in range(start_row + 1, end_row) {
                result += '\n' + source_lines[row];
            }
            result += '\n' + source_lines[end_row][:end_col];
            return result;
        }
    }
    
    can extract_docstring(node: Any, source_lines: List[str]) -> Optional[str] {
        """Extract docstring from function or class node"""
        # Look for string literal as first statement in body
        body = node.child_by_field_name('body');
        if body and len(body.children) > 0 {
            first_statement = body.children[0];
            if first_statement.type == 'expression_statement' {
                expr = first_statement.children[0];
                if expr.type == 'string' {
                    docstring = self.get_node_text(expr, source_lines);
                    # Clean up the docstring (remove quotes)
                    return docstring.strip('"\'');
                }
            }
        }
        return None;
    }
    
    can calculate_complexity_score(node: Any) -> int {
        """Calculate a simple complexity score based on AST node structure"""
        complexity = 1;  # Base complexity
        
        # Add complexity for control flow statements
        complexity_nodes = ['if_statement', 'for_statement', 'while_statement', 
                           'try_statement', 'with_statement'];
        
        def count_complexity(current_node: Any) -> int {
            score = 0;
            if current_node.type in complexity_nodes {
                score += 1;
            }
            for child in current_node.children {
                score += count_complexity(child);
            }
            return score;
        }
        
        complexity += count_complexity(node);
        return complexity;
    }
    
    can is_supported_file(file_path: str) -> bool {
        """Check if file type is supported for analysis"""
        file_ext = Path(file_path).suffix.lower();
        supported_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.h'];
        return file_ext in supported_extensions;
    }
    
    can detect_language(file_path: str) -> str {
        """Detect programming language from file extension"""
        file_ext = Path(file_path).suffix.lower();
        language_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c',
            '.h': 'c'
        };
        return language_map.get(file_ext, 'unknown');
    }
}

# Walker for handling analysis requests
walker AnalyzeCode {
    has file_paths: List[str];
    
    can analyze with CodeAnalyzer entry {
        analysis_results = here.analyze_files(self.file_paths);
        report f"Code analysis completed for {len(self.file_paths)} files";
        return analysis_results;
    }
}